SMTP Engine Call-Backs
----------------------

When smtpe first starts, it creates a master Lua state (interpreter) and
loads and executes ``/etc/smtpe.lua'' (see option script). If the script
is missing, or there is a syntax or memory error, then smtpe will fail
to start.

When an SMTP client connects, a new Lua thread is created from the
master Lua state. The each Lua hook back into smtpe is optional, ie.
doesn't need to be defined.


Client Connection Variables
---------------------------

client.address

	Available from hook.accept to hook.close

client.port

	Available from hook.accept to hook.close

client.host

	Available from hook.accept to hook.close

client.id_sess

	Session ID available from hook.accept to hook.close

client.id_trans

	Transaction ID available from hook.mail to hook.forward;
	discarded by RSET, HELO, EHLO, or end of transaction.

client.msg_file

	Available from hook.data to hook.forward; discarded by RSET,
	HELO, EHLO, or end of transaction.

client.input

	Available in each SMTP command related hook (HELO, EHLO, AUTH,
	MAIL, RCPT, DATA, QUIT, RSET, NOOP, HELP, XCLIENT, unknown, error).

client.is_pipelining

	True when the client has been detected pipelining SMTP commands.


Client SMTP Input Hooks
-----------------------

A hook can return either a correctly formatted SMTP (multi-line) reply
with CRLF newline or no reply. If no reply message is returned, or there
is an error, then a default reply is sent back to the client. Undefined
hooks are ignored.

A hook can optionally return a boolean before the reply. When true the
SMTP client connection will be dropped after the reply has been written
back to the client.

[drop_flag,] reply = hook.accept(ip, ptr)

	ip = client.address; ptr = client.host

[drop_flag,] reply = hook.helo(helo_arg)


[drop_flag,] reply = hook.ehlo(helo_arg)


[drop_flag,] reply = hook.auth(auth_arg)

	Should return 235 for successful authentication.

[drop_flag,] reply = hook.out_seq(smtp_input)

	Should always return 501 out of sequence.

[drop_flag,] reply = hook.unknown(smtp_input)

	Should always return 502 command unknown.

[drop_flag,] reply = hook.mail(sender)


[drop_flag,] reply = hook.rcpt(recipient)


[drop_flag,] reply = hook.data()

	Should return "354 text" to continue, "4xy text", or "5xy text".

hook.content(chunk_of_lines_as_a_string)


hook.header(header_line)


hook.eoh()


hook.body(body_line)


[drop_flag,] reply = hook.dot(spool_file_path)

	A negative reply will skip forwarding of the message. No reply
	or a positive reply will continue and forward the message. The
	possitive reply is held until the result of forwarding is known.
	hook.forward() may override the reply with its own positive or
	negative reply.

[drop_flag,] reply = hook.forward(spool_file_path)

	If no reply or a Lua error, then the smtp-smart-host option, if
	defined is used to forward the message. A positive or negative
	reply will skip smtp-smart-host forwarding.

hook.reset()

	Invoked for RSET, HELO, EHLO, and end of message (DOT).

[drop_flag,] reply = hook.rset()

	Should always return 250 OK.

[drop_flag,] reply = hook.noop()

	Should always return 250 OK.

[drop_flag,] reply = hook.help()

	Should always return 214 text.

[drop_flag,] reply = hook.quit()

	Should always return 221 text.

[drop_flag,] reply = hook.xclient()

	A negative reply will prevent the XCLIENT command from being
	applied.

hook.error(errno, errno_text)


hook.close(was_dropped)

	End of SMTP connection and clean-up.


DNS Support Functions
---------------------

	Constants

		dns.class.IN
		dns.class.CS
		dns.class.CH
		dns.class.HS

		dns.type.A
		dns.type.AAAA
		dns.type.CNAME
		dns.type.DNAME
		dns.type.MX
		dns.type.NS
		dns.type.PTR
		dns.type.SOA
		dns.type.TXT

		dns.rcode.OK
		dns.rcode.NOERROR
		dns.rcode.FORMAT
		dns.rcode.SERVFAIL
		dns.rcode.NXDOMAIN
		dns.rcode.NOT_IMPLEMENTED
		dns.rcode.REFUSED
		dns.rcode.ERRNO
		dns.rcode.TIMEOUT

	Functions

dns.open()

	Opens a DNS socket for the duration of a hook handler. There is
	no dns.close(). When a Lua hook completes the DNS socket and
	related data will be recovered.

dns.close()


dns.reset()

	Reset socket timeout and clears any previous collected answers.

dns.query(dns.class, dns.type, name)

	Send a DNS query. This can be done multiple times before collecting
	the results with dns.wait().

boolean = dns.ispending()

	Return true if there are still queries pending.

answers = dns.wait(for_all_flag)

	Wait for one or more pending DNS queries to complete. If for_all_flag
	is true, then wait for all pending queries; otherwise return as soon
	what ever queries have completed.

	Return an answer array containing the queries and their results. If
	an error occured the answers array will be nil.

	answers[i] = { query }

	answers[query_key] = { query }

	query_key = dns.class..","..dns.type..","..name

	query = { rcode, name, class, type, ttl, answer = [ RR ], extra = [ RR ], authority = [ RR ] }


	Resource Recode formats for dns.type
	------------------------------------

	A	= { name, class, type, ttl, address }
	AAAA	= { name, class, type, ttl, address }
	PTR	= { address, class, type, ttl, name }
	CNAME	= { name, class, type, ttl, host }
	DNAME	= { name, class, type, ttl, host }
	MX	= { name, class, type, ttl, host, preference }
	NS	= { name, class, type, ttl, host }
	SOA	= { name, class, type, ttl, mname, rname, serial, refresh, retry, expire, minimum, }
	TXT	= { name, class, type, ttl, text }

string = dns.classname(dns.class)


string = dns.typename(dns.type)


string = dns.rcodename(dns.rcode)


HTTP API
--------

	Constants

		http.code.CONTINUE
		http.code.DROP

		http.code.OK
		http.code.CREATED
		http.code.ACCEPTED
		http.code.NON_AUTH_INFO
		http.code.NO_CONTENT
		http.code.RESET_CONTENT
		http.code.PARTIAL_CONTENT

		http.code.MULTIPLE_CHOICES
		http.code.MOVED_PERMANENTLY
		http.code.FOUND
		http.code.SEE_OTHER
		http.code.NOT_MODIFIED
		http.code.USE_PROXY
		http.code.TEMPORARY_REDIRECT

		http.code.BAD_REQUEST
		http.code.UNAUTHORIZED
		http.code.PAYMENT_REQUIRED
		http.code.FORBIDDEN
		http.code.NOT_FOUND
		http.code.METHOD_NOT_ALLOWED
		http.code.NOT_ACCEPTABLE
		http.code.PROXY_AUTH_REQUIRED
		http.code.REQUEST_TIMEOUT
		http.code.CONFLICT
		http.code.GONE
		http.code.LENGTH_REQUIRED
		http.code.PRECOND_FAILED
		http.code.REQUEST_TOO_LARGE
		http.code.URI_TOO_LONG
		http.code.UNSUPPORTED_MEDIA
		http.code.RANGE_NOT_POSSIBLE
		http.code.EXPECTATION_FAILED

		http.code.INTERNAL
		http.code.NOT_IMPLEMENTED
		http.code.BAD_GATEWAY
		http.code.SERVICE_UNAVAILABLE
		http.code.GATEWAY_TIMEOUT
		http.code.VERSION_NOT_SUPPORTED

	Functions

table = http.action(method, url, modified_since, post)

	Perform an HTTP request as denoted by a method string ("GET",
	"HEAD", "POST") to the given url string. The post argument can
	be nil or a string of data to submit using "POST" method.

	The modified_since argument can be either a number or a string.
	As a number it represent the GMT seconds since the epoch. As a
	string it is an RFC 2822 Date & Time or ctime(). The argument
	is used to make a conditional request based on how recently
	any changes to the url were made. Specify zero (0) to always
	do the request.

		table.id
		table.rcode
		table.headers
		table.content


table = http.get(url, modified_since)


table = http.head(url, modified_since)


table = http.post(url, modified_since, post)


MD5 Functions
-------------

md5_obj = md5.new()


md5_obj:append(string)


digest = md5_obj:done()


boolean = md5_obj:use_ixhash1(string)

	Use ixhash1 if the message contains at least 2 lines and at
	least 20 spaces or tabs.


boolean = md5_obj:use_ixhash2(string)

	Use ixhash2 if the message contains at least three occurences
	of:

		< > ( ) | @ * ' ! ? ,

	or the combination ":/"


boolean = md5_obj:use_ixhash3(string)

	Otherwise use ixhash3 if the message has a minimum amount of
	content.


md5_obj:ixhash1(string)


md5_obj:ixhash2(string)


md5_obj:ixhash3(string)


MIME Message Table
------------------

This table is created when a transaction starts with MAIL and is discard
by RSET, HELO, EHLO, or at the end of message when the transaction
completes.

mime.parts

	An array of message MIME parts in linear order of appearance.
	The top level message headers start with mime.parts[1]. The
	number of mime parts is given by "# mime.parts".

mime.parts[i].md5_encoded

	The MD5 of the MIME part body encoded.

mime.parts[i].md5_decoded

	The MD5 of the MIME part body after decoding the body based on
	Content-Transfer-Encoding

mime.parts[i].part_length

	The length of the MIME part, bother headers and body.

mime.parts[i].body_length

	The encoded length of the MIME part body.

mime.parts[i].content_type

	A copy of the Content-Type header.

mime.parts[i].content_transfer_encoding

	A copy of the Content-Transfer-Encoding header.


Network Support Functions
-------------------------

boolean = net.contains_ip(net_cidr_string, ip_string)


boolean = net.has_valid_tld(string)

	Return true the string ends with a valid two or one level TLD.

boolean = net.has_valid_nth_tld(string, level)

	Return true if the string ends with a valid top level domain.
	Check Nth top level domain, ie. .co.uk or .com.au. Valid
	levels are 1 or 2.

offset = net.index_valid_tld(string)

	The index in the string of a valid two or one level TLD;
	otherwise 0 if not found.

offset = net.index_valid_nth_tld(string, level)

	Find the Nth level from the right end of the domain string.
	Valid levels are 1 or 2. The index (1 based) in the string;
	otherwise 0 if not found.

string = net.reverse_ip(address, arpa_suffix_flag)


integer = net.is_ipv4_in_name(ipv4, string)

	Check if the string contains the IPv4 octets in the strings
	according to a series of adhoc checks. Return 0 if the string
	does not contain any element of the IPv4 address; otherwise an
	integer corresponding to the test that matched.

	TODO: document the test return codes.


offset, span = net.find_ip(string)

	Return the offset and span of the first occurence of an IPv4 or
	IPv6 addres in string; otherwise nil if not found.


boolean = net.is_ip_reserved(address, is_ip_bits)

		net.is_ip.BENCHMARK
		net.is_ip.LINK_LOCAL
		net.is_ip.LOCALHOST
		net.is_ip.LOOPBACK
		net.is_ip.MULTICAST
		net.is_ip.PRIVATE_A
		net.is_ip.PRIVATE_B
		net.is_ip.PRIVATE_C
		net.is_ip.RESERVED
		net.is_ip.SITE_LOCAL
		net.is_ip.TEST_NET
		net.is_ip.THIS_HOST
		net.is_ip.THIS_NET
		net.is_ip.V4_COMPATIBLE
		net.is_ip.V4_MAPPED
		net.is_ip.V6

		net.is_ip.V4		= net.is_ip.V4_COMPATIBLE
					+ net.is_ip.V4_MAPPED

		net.is_ip.ANY		= 0xffff - (net.is_ip.V4 + net.is_ip.V6)

		net.is_ip.TEST		= net.is_ip.BENCHMARK
					+ net.is_ip.TEST_NET

		net.is_ip.LOCAL		= net.is_ip.THIS_HOST
					+ net.is_ip.LOCALHOST
					+ net.is_ip.LOOPBACK

		net.is_ip.LAN		= net.is_ip.PRIVATE_A
					+ net.is_ip.PRIVATE_B
					+ net.is_ip.PRIVATE_C
					+ net.is_ip.LINK_LOCAL
					+ net.is_ip.SITE_LOCAL

		net.is_ip.RESTICTED	= net.is_ip.TEST
					+ net.is_ip.LOCAL
					+ net.is_ip.LAN
					+ net.is_ip.MULTICAST
					+ net.is_ip.RESERVED


SMTP Client
-----------

	Constants

		--
		-- RFC 821, 2821, 5321 codes.
		--
		smtp.code.STATUS
		smtp.code.HELP
		smtp.code.WELCOME
		smtp.code.GOODBYE
		smtp.code.AUTH_OK		-- RFC 4954 section 6
		smtp.code.OK
		smtp.code.USER_NOT_LOCAL

		smtp.code.WAITING

		smtp.code.CLOSING
		smtp.code.AUTH_MECHANISM	-- RFC 4954 section 6
		smtp.code.BUSY
		smtp.code.TRY_AGAIN_LATER
		smtp.code.NO_STORAGE
		smtp.code.AUTH_TEMP		-- RFC 4954 section 6

		smtp.code.BAD_SYNTAX
		smtp.code.BAD_ARGUMENTS
		smtp.code.UNKNOWN_COMMAND
		smtp.code.BAD_SEQUENCE
		smtp.code.UNKNOWN_PARAM
		smtp.code.AUTH_REQUIRED		-- RFC 4954 section 6
		smtp.code.AUTH_WEAK		-- RFC 4954 section 6
		smtp.code.AUTH_FAIL		-- RFC 4954 section 6
		smtp.code.AUTH_ENCRYPT		-- RFC 4954 section 6
		smtp.code.REJECT
		smtp.code.UNKNOWN_USER
		smtp.code.OVER_QUOTA
		smtp.code.BAD_ADDRESS
		smtp.code.TRANSACTION_FAILED

		--
		-- Error conditions indicated SMTP like codes.
		--
		smtp.code.ERROR
		smtp.code.ERROR_CONNECT
		smtp.code.ERROR_TIMEOUT
		smtp.code.ERROR_EOF
		smtp.code.ERROR_IO


	Functions

smtp.code, n_rcpt_ok = smtp.sendfile(hosts[], mail, rcpts[], spool)

	Send the spool file to host, which can be a host name, ipv4, or
	ipv6 address with optional colon port suffix, eg.
	[2001:0Db8::1]:2525. Specify the mail address and an array of
	one or more recipents. The smtp.code return is the last read.
	The number of successful recipients accepted is returned. The
	spool file can be nil, in which case the function ends after the
	last RCPT command and before DATA.


smtp.code, n_rcpt_ok = smtp.sendstring(hosts[], mail, rcpts[], message)


SMTP Engine Global Variables
----------------------------

smtpe.bin_version


smtpe.api_version


smtpe.copyright


smtpe.host


Syslog Functions
----------------

syslog.open(ident, options, facility)

	Typically not required since the logging will have been setup
	by the application.

	Or-able option flags:

		syslog.LOG_PID
		syslog.LOG_CONS
		syslog.LOG_ODELAY
		syslog.LOG_NDELAY
		syslog.LOG_NOWAIT
		syslog.LOG_PERROR

	Choice of facility:

		syslog.LOG_KERN
		syslog.LOG_USER
		syslog.LOG_MAIL
		syslog.LOG_DAEMON
		syslog.LOG_AUTH
		syslog.LOG_SYSLOG
		syslog.LOG_LPR
		syslog.LOG_NEWS
		syslog.LOG_UUCP
		syslog.LOG_CRON
		syslog.LOG_AUTHPRIV
		syslog.LOG_FTP
		syslog.LOG_LOCAL0
		syslog.LOG_LOCAL1
		syslog.LOG_LOCAL2
		syslog.LOG_LOCAL3
		syslog.LOG_LOCAL4
		syslog.LOG_LOCAL5
		syslog.LOG_LOCAL6
		syslog.LOG_LOCAL7

syslog.log(level, message)

	Possible log levels:

		syslog.LOG_EMERG
		syslog.LOG_ALERT
		syslog.LOG_CRIT
		syslog.LOG_ERR
		syslog.LOG_WARNING
		syslog.LOG_NOTICE
		syslog.LOG_INFO
		syslog.LOG_DEBUG

syslog.error(message)

	Equivalent to

		syslog.log(syslog.LOG_ERR, message)

syslog.info(message)

	Equivalent to

		syslog.log(syslog.LOG_INFO, message)

syslog.debug(message)

	Equivalent to

		syslog.log(syslog.LOG_DEBUG, message)

syslog.close()

	Typically not required since the logging will be closed
	by the application.


Text API
--------

offset = text.find(haystack, needle, caseless)

	Find the first occurence of "needle" in "haystack" and return
	the offset into the haystack where found; otherwise zero (0).

	An astrisk (*) acts as wildcard, scanning over zero or more
	bytes. A question-mark (?) matches any single character; a
	space ( ) will match any single white space character.

	A left square bracket ([) starts a character class that ends
	with a right square bracket (]) and matches one character from
	the class. If the first character of the class is a carat (^),
	then the remainder of character class is negated. If the first
	character (after a carat if any) is a right square bracket, then
	the right square bracket is a literal and loses any special
	meaning. If the first character (after a carat and/or right
	square bracket) is a hypen (-), then the hyphen is a literal and
	loses any special meaning. A range expression expressed as a
	start character followed by a hyphen followed by an end
	character matches a character in character-set order between
	start and end characters inclusive.

	A backslash followed by any character treats that character as a
	literal (it loses any special meaning).

	(If you need more than that, think about using regex(3) instead.)

		"abc"		exact match for "abc"

		"abc*"		match "abc" at start of string

		"*abc"		match "abc" at the end of string

		"abc*def"	match "abc" at the start and match "def"
				at the end, maybe with stuff in between.

		"*abc*def*"	find "abc", then find "def"

		"a[]]c"		exact match for "a]c", same as "a]c"

		"[abc]"		match a single "a", "b", or "c".

		"[^abc]"	match a single charcater except "a", "b", or "c".

		"[a-z]"		match a single character "a" through "z" (assumes ASCII)

		"[0-9]"		match a single digit "0" through "9" (assumes ASCII)

		"[-ac]"		match a single charcater "-", "a", or "c".

		"[]-ac]		match a single charcater "]", "-", "a", or "c".

		"[^-ac]"	match a single charcater except "-", "a", or "c".

		"[^]-ac]"	match a single charcater execpt "]", "-", "a", or "c".


diff = text.natcmp(s1, s2, caseless)

	Return an integer greater than, equal to, or less than 0,
	according to whether the string s1 is greater than, equal to, or
	less than the string s2 according to natural sorting order.

	Note that either s1 or s2 can be nil, in which case nil equals nil
	and nil is greater than anything else; this means nil would sort
	to the end of an array of strings.


array = text.split(string, delims)

	The given string contains a list of substrings separated by the
	specified delimiter characters. The substrings may contain quoted
	strings and/or contain backslash-escaped characters. The common
	backslash escape sequences are supported and return their ASCII
	values.


URI
---

table = uri.parse(string)

	Attempt to parse the given URI string into its component parts.
	If the string is not a URI, then nil is returned.

		table.uri_raw
		table.uri_decoded
		table.scheme
		table.scheme_info
		table.user_info
		table.host
		table.port
		table.query
		table.fragment

uri.found

	This array is created when a transaction starts with MAIL and is
	discard by RSET, HELO, EHLO, or at the end of message when the
	transaction completes. An array of unique uri entries. The
	number of entries given by "# uri.found".

uri.found[i] = md5_key

	For each URI found, the uri_raw field is converted to an MD5 and
	used as a key by which to save the URI. The MD5 is added to the
	table, primarily so that the Lua length operator, #, works. By
	using the MD5 of the uri_raw as a key, it allows for an
	existance test so as to avoid duplicate entries.

		uri.found[md5_key].uri_raw
		uri.found[md5_key].uri_decoded
		uri.found[md5_key].scheme
		uri.found[md5_key].scheme_info
		uri.found[md5_key].user_info
		uri.found[md5_key].host
		uri.found[md5_key].port
		uri.found[md5_key].query
		uri.found[md5_key].fragment

	To walk through the table:

		for k,v in pairs(uri.found) do
			if type(k) ~= "number" then
				-- operate on uri[k]
			end
		end


Utility Support
---------------

boolean = util.mkpath(string)

	The absolute or relative directory path to create. True on
	success.

length[, integer] = util.date_to_time(string)

	Convert an RFC 2822 Date & Time string into seconds from the epoch.
	Return the length of the parsed portion of the string and a number
	of seconds from the epoch; otherwise return a zero length if the
	string could not be parsed.

	This conforms:		Sun, 21 Sep 2003 22:04:27 +0200

	Obsolete form:		Sun, 21 Sep 03 11:30:38 GMT	(named zone)

	Bad, but supported:	Mon Sep 22 01:39:09 2003 -0000	(ctime() + zone)

	Not supported:		Mon, 22 Sep 2003 20:02:33 PM	(AM/PM not zones)

	Not supported:		Mon 22 Sep 20:02:33 CDT 2003	(year & zone out of order)

	The following formats are supported:

		[www[,]] dd mmm yyyy [HH:MM:SS [zzzzzz]]
		[www[,]] mmm dd HH:MM:SS yyyy [zzzzzz]

	If the time zone is missing, then GMT (+0000) is assumed, which may
	cause undefined results if the time values are used for non-local
	comparisions.


-END-
