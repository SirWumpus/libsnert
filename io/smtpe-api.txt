SMTP Engine Call-Backs
----------------------

When smtpe first starts, it creates a master Lua state (interpreter) and
loads and executes ``/etc/smtpe.lua'' (see option script). If the script
is missing, or there is a syntax or memory error, then smtpe will fail
to start.

When an SMTP client connects, a new Lua thread is created from the
master Lua state. The each Lua hook back into smtpe is optional, ie.
doesn't need to be defined.


SMTP Engine Variables
---------------------

smtpe.bin_version


smtpe.api_version


smtpe.copyright


smtpe.host


Client SMTP Variables
---------------------

client.address

	Available from hook.accept to hook.close

client.port

	Available from hook.accept to hook.close

client.host

	Available from hook.accept to hook.close

client.id_log

	Available from hook.accept to hook.close

client.id_trans

	Available from hook.mail to hook.forward; cleared by RSET, HELO, EHLO.

client.msg_file

	Available from hook.mail to hook.forward; cleared by RSET, HELO, EHLO.

client.input

	Available in each SMTP command related hook (HELO, EHLO, AUTH, MAIL,
	RCPT, DATA, RSET, unknown, error).

client.is_pipelining

	True when the client has been detected pipelining SMTP commands.


Client SMTP Input Hooks
-----------------------

A hook can return either a correctly formatted SMTP (multi- line) reply
with CRLF newline or nothing. If no reply message is returned, or there
is an error, then a default reply is sent back to the client. Undefined
hooks are ignored.


reply = hook.accept(ip, ptr)

	ip = client.address; ptr = client.host

reply = hook.helo(helo_arg)


reply = hook.ehlo(helo_arg)


reply = hook.auth(auth_arg)

	Should return 235 for successful authentication.

reply = hook.unknown(smtp_input)

	Should always return 502 command unknown.

reply = hook.mail(sender)


reply = hook.rcpt(recipient)


reply = hook.data()

	Should return "354 text" to continue, "4xy text", or "5xy text".

hook.content(chunk_of_lines_as_a_string)


hook.header(header_line)


hook.eoh()


hook.body(body_line)


reply = hook.dot(spool_file_path)

	NOTE that this hook should only ever return 4xy or 5xy replies.
	Returning a 2xy reply will cause an extra reply message to be
	sent to the client if smtp-smart-host is enabled and thus
	put the client out of sync.

reply = hook.forward(spool_file_path)


hook.reset()

	Invoked for RSET, HELO, EHLO, and end of message (DOT).

reply = hook.rset()

	Should always return 250 OK.

reply = hook.noop()

	Should always return 250 OK.

reply = hook.help()

	Should always return 214 text.

reply = hook.quit()

	Should always return 221 text.

reply = hook.xclient()

	NOTE that this hook should only ever return 4xy or 5xy replies.
	To continue with the XCLIENT command, return nothing. Returning a
	2xy reply will cause an extra reply message to be sent to the
	client and thus put the client out of sync.

hook.error(errno, errno_text)


hook.close()

	End of SMTP connection and clean-up.


DNS Support Functions
---------------------

	Constants

		dns.class.IN
		dns.class.CS
		dns.class.CH
		dns.class.HS

		dns.type.A
		dns.type.AAAA
		dns.type.CNAME
		dns.type.DNAME
		dns.type.MX
		dns.type.NS
		dns.type.SOA
		dns.type.TXT

		dns.rcode.OK
		dns.rcode.NOERROR
		dns.rcode.FORMAT
		dns.rcode.SERVFAIL
		dns.rcode.NXDOMAIN
		dns.rcode.NOT_IMPLEMENTED
		dns.rcode.REFUSED
		dns.rcode.ERRNO
		dns.rcode.TIMEOUT

	Functions

dns.open()

	Opens a DNS socket for the duration of a hook handler. There is
	no dns.close(). When a Lua hook completes the DNS socket and
	related data will be recovered.

dns.reset()

	Reset socket timeout and clears any previous collected answers.

dns.query(dns.class, dns.type, name)

	Send a DNS query. This can be done multiple times before collecting
	the results with dns.wait().

dns.rcode, rr_table = dns.wait(for_all_flag)

	Wait for one or more pending DNS queries to complete. If for_all_flag
	is true, then wait for all pending queries; otherwise return as soon
	what ever queries have completed.

	Return the DNS rcode and a table containing answer, extra, and/or
	authority resource records. If an error occured the rr_table will
	be nil.

		rr_table = { answer = [RR], extra = [RR], authority = [RR] }


		RR formats for dns.type
		-----------------------

		A = { name, dns.class, dns.type, ttl, address }
		AAAA = { name, dns.class, dns.type, ttl, address }
		PTR = { address, dns.class, dns.type, ttl, name }
		CNAME = { name, dns.class, dns.type, ttl, host }
		DNAME = { name, dns.class, dns.type, ttl, host }
		MX = { name, dns.class, dns.type, ttl, host, preference }
		NS = { name, dns.class, dns.type, ttl, host }
		SOA = { name, dns.class, dns.type, ttl, mname, rname, serial, refresh, retry, expire, minimum, }
		TXT = { name, dns.class, dns.type, ttl, text }


string = dns.classname(dns.class)


string = dns.typename(dns.type)


string = dns.rcodename(dns.rcode)


Network Support Functions
-------------------------

string = net.reverseip(address, arpa_suffix_flag)


Syslog Functions
----------------

syslog.open(ident, options, facility)

	Typically not required since the logging will have been setup
	by the application.

	Or-able option flags:

		syslog.LOG_PID
		syslog.LOG_CONS
		syslog.LOG_ODELAY
		syslog.LOG_NDELAY
		syslog.LOG_NOWAIT
		syslog.LOG_PERROR

	Choice of facility:

		syslog.LOG_KERN
		syslog.LOG_USER
		syslog.LOG_MAIL
		syslog.LOG_DAEMON
		syslog.LOG_AUTH
		syslog.LOG_SYSLOG
		syslog.LOG_LPR
		syslog.LOG_NEWS
		syslog.LOG_UUCP
		syslog.LOG_CRON
		syslog.LOG_AUTHPRIV
		syslog.LOG_FTP
		syslog.LOG_LOCAL0
		syslog.LOG_LOCAL1
		syslog.LOG_LOCAL2
		syslog.LOG_LOCAL3
		syslog.LOG_LOCAL4
		syslog.LOG_LOCAL5
		syslog.LOG_LOCAL6
		syslog.LOG_LOCAL7

syslog.log(level, message)

	Possible log levels:

		syslog.LOG_EMERG
		syslog.LOG_ALERT
		syslog.LOG_CRIT
		syslog.LOG_ERR
		syslog.LOG_WARNING
		syslog.LOG_NOTICE
		syslog.LOG_INFO
		syslog.LOG_DEBUG

syslog.error(message)

	Equivalent to

		syslog.log(syslog.LOG_ERR, message)

syslog.info(message)

	Equivalent to

		syslog.log(syslog.LOG_INFO, message)

syslog.debug(message)

	Equivalent to

		syslog.log(syslog.LOG_DEBUG, message)

syslog.close()

	Typically not required since the logging will be closed
	by the application.
