--- strnatcmp.c.orig	Mon Feb 11 11:49:03 2008
+++ strnatcmp.c	Mon Feb 11 15:01:20 2008
@@ -18,52 +18,28 @@
   2. Altered source versions must be plainly marked as such, and must not be
      misrepresented as being the original software.
   3. This notice may not be removed or altered from any source distribution.
-*/
 
+  Originally from http://sourcefrog.net/projects/natsort/
 
-/* partial change history:
- *
- * 2004-10-10 mbp: Lift out character type dependencies into macros.
- *
- * Eric Sosman pointed out that ctype functions take a parameter whose
- * value must be that of an unsigned int, even on platforms that have
- * negative chars in their default char type.
- */
+	2008-2-11 Anthony C Howe <achowe at snert dot com>:
+
+  	Fixes for ANSI C portability. The ctype functions take an "int",
+  	NOT an "unisgned int" as claimed by Eric Sosman based on a comment
+  	in the code (since removed). See ANSI C 89 copy section 4.3:
+
+  	"In all cases the argument is an ''int'', the value of which shall be
+  	representable as an ''unsigned char'' or shall equal the value of the
+  	macros EOF. If the argument has any other value, the behaviour of is
+  	undefined."
+*/
 
 #include <ctype.h>
 #include <string.h>
 #include <assert.h>
 #include <stdio.h>
 
-#include "strnatcmp.h"
-
-
-/* These are defined as macros to make it easier to adapt this code to
- * different characters types or comparison functions. */
-static inline int
-nat_isdigit(nat_char a)
-{
-     return isdigit((unsigned char) a);
-}
-
-
-static inline int
-nat_isspace(nat_char a)
-{
-     return isspace((unsigned char) a);
-}
-
-
-static inline nat_char
-nat_toupper(nat_char a)
-{
-     return toupper((unsigned char) a);
-}
-
-
-
 static int
-compare_right(nat_char const *a, nat_char const *b)
+compare_right(const unsigned char *a, const unsigned char *b)
 {
      int bias = 0;
 
@@ -72,11 +48,11 @@
 	both numbers to know that they have the same magnitude, so we
 	remember it in BIAS. */
      for (;; a++, b++) {
-	  if (!nat_isdigit(*a)  &&  !nat_isdigit(*b))
+	  if (!isdigit(*a)  &&  !isdigit(*b))
 	       return bias;
-	  else if (!nat_isdigit(*a))
+	  else if (!isdigit(*a))
 	       return -1;
-	  else if (!nat_isdigit(*b))
+	  else if (!isdigit(*b))
 	       return +1;
 	  else if (*a < *b) {
 	       if (!bias)
@@ -93,16 +69,16 @@
 
 
 static int
-compare_left(nat_char const *a, nat_char const *b)
+compare_left(const unsigned char *a, const unsigned char *b)
 {
      /* Compare two left-aligned numbers: the first to have a
         different value wins. */
      for (;; a++, b++) {
-	  if (!nat_isdigit(*a)  &&  !nat_isdigit(*b))
+	  if (!isdigit(*a)  &&  !isdigit(*b))
 	       return 0;
-	  else if (!nat_isdigit(*a))
+	  else if (!isdigit(*a))
 	       return -1;
-	  else if (!nat_isdigit(*b))
+	  else if (!isdigit(*b))
 	       return +1;
 	  else if (*a < *b)
 	       return -1;
@@ -114,10 +90,10 @@
 }
 
 
-static int strnatcmp0(nat_char const *a, nat_char const *b, int fold_case)
+static int strnatcmp0(const unsigned char *a, const unsigned char *b, int fold_case)
 {
      int ai, bi;
-     nat_char ca, cb;
+     unsigned char  ca, cb;
      int fractional, result;
 
      assert(a && b);
@@ -126,14 +102,14 @@
 	  ca = a[ai]; cb = b[bi];
 
 	  /* skip over leading spaces or zeros */
-	  while (nat_isspace(ca))
+	  while (isspace(ca))
 	       ca = a[++ai];
 
-	  while (nat_isspace(cb))
+	  while (isspace(cb))
 	       cb = b[++bi];
 
 	  /* process run of digits */
-	  if (nat_isdigit(ca)  &&  nat_isdigit(cb)) {
+	  if (isdigit(ca)  &&  isdigit(cb)) {
 	       fractional = (ca == '0' || cb == '0');
 
 	       if (fractional) {
@@ -152,8 +128,8 @@
 	  }
 
 	  if (fold_case) {
-	       ca = nat_toupper(ca);
-	       cb = nat_toupper(cb);
+	       ca = toupper(ca);
+	       cb = toupper(cb);
 	  }
 
 	  if (ca < cb)
@@ -167,12 +143,39 @@
 
 
 
-int strnatcmp(nat_char const *a, nat_char const *b) {
-     return strnatcmp0(a, b, 0);
+/**
+ * Natural string compare.
+ *
+ * @param s1
+ *	A C string.
+ *
+ * @param s2
+ *	A C string.
+ *
+ * @return
+ *	An integer greater than, equal to, or less than 0, according to
+ *	whether the string s1 is greater than, equal to, or less than the
+ *	string s2 according to natural sorting order.
+ */
+int strnatcmp(const char *s1, const char *s2) {
+     return strnatcmp0((const unsigned char *) s1, (const unsigned char *) s2, 0);
 }
 
 
-/* Compare, recognizing numeric string and ignoring case. */
-int strnatcasecmp(nat_char const *a, nat_char const *b) {
-     return strnatcmp0(a, b, 1);
+/**
+ * Natural string caseless compare.
+ *
+ * @param s1
+ *	A C string.
+ *
+ * @param s1
+ *	A C string.
+ *
+ * @return
+ *	An integer greater than, equal to, or less than 0, according to
+ *	whether the string s1 is greater than, equal to, or less than the
+ *	string s2 according to natural sorting order.
+ */
+int strnatcasecmp(const char *s1, const char *s2) {
+     return strnatcmp0((const unsigned char *) s1, (const unsigned char *) s2, 1);
 }
